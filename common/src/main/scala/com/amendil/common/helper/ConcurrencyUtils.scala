package com.amendil.common.helper

import java.util.concurrent.atomic.AtomicBoolean
import scala.collection.mutable.ListBuffer
import scala.concurrent.{ExecutionContext, Future}

/**
  * Inspiration taken from https://stackoverflow.com/questions/20414500/how-to-do-sequential-execution-of-futures-in-scala
  * in order to replace some recursions by interations
  */
object ConcurrencyUtils:

  /**
    * Take the element and call sequentially and in order the provided asychronous functions.
    *
    * The argument of the first function will be the provided element.
    * The argument of the following functions will be the result of the previous function.
    *
    * @return The result of the very last function, if no function has been provided, returns the provided element
    */
  def executeChain[T, U](element: T, fns: Seq[(T) => Future[T]])(using ExecutionContext): Future[T] =
    val initF = Future.successful(element)
    fns.foldLeft(initF)((resF, fn) => resF.flatMap(el => fn(el)))

  /**
    * The maxConcurrency is handled by grouping the elements into maxConcurrency partition (or bucket).
    * Each partition execute the function on its group of elements sequentially.
    * Partitions are executed in parallel.
    *
    * Whenever a computation fails, all partitions stop and the Future.Failure generated by that computation is returned.
    *
    * The order of the elements is kept. This function can be seen like an asynchronous `map` operation.
    *
    * @return A sequence of the same size as the provided elements
    * @throws IllegalArgumentException when maxConcurrency is less than 1
    */
  def executeInParallel[T, U](elements: Seq[T], fn: (T) => Future[U], maxConcurrency: Int)(
      using ExecutionContext
  ): Future[Seq[U]] =
    val partitionSize =
      if elements.size == 0 || maxConcurrency < 1 then 1
      else Math.ceil(elements.size.toFloat / maxConcurrency).toInt

    val hasFailed = AtomicBoolean(false)
    val futures = elements
      .grouped(partitionSize)
      .map { (subElements: Seq[T]) =>
        executeInSequence(
          subElements,
          el =>
            if hasFailed.get then
              Future
                .failed(Exception("Another element executed in parallel has failed, automatically failing this one."))
            else
              fn(el).recover { err =>
                hasFailed.set(true)
                throw err
              }
        )
      }

    Future.sequence(futures).map(_.flatten.toSeq)

  /**
    * The maxConcurrency is handled by grouping the elements into maxConcurrency partition (or bucket).
    * Each partition execute the function on its group of elements sequentially.
    * Partitions are executed in parallel.
    *
    * Results of failing queries are skipped.
    *
    * The order of the elements is kept. This function can be seen like an asynchronous `collect` operation.
    *
    * @return A sequence which maximum size is the number of provided elements
    * @throws IllegalArgumentException when maxConcurrency is less than 1
    */
  def executeInParallelOnlySuccess[T, U](elements: Seq[T], fn: (T) => Future[U], maxConcurrency: Int)(
      using ExecutionContext
  ): Future[Seq[U]] =
    val partitionSize =
      if elements.size == 0 || maxConcurrency < 1 then 1
      else Math.ceil(elements.size.toFloat / maxConcurrency).toInt

    val futures = elements
      .grouped(partitionSize)
      .map { (subElements: Seq[T]) =>
        executeInSequence(
          subElements,
          el => fn(el).map[Option[U]](Some(_)).recover(_ => None)
        )
      }

    Future.sequence(futures).map(_.flatten.flatten.toSeq)

  /**
    * Executes all calls in parallel until receiving a Future.Success
    * This is done by calling one function followed by recoverWith to call the next one.
    *
    * @return A Future.Success if one call worked, Future.Failure otherwise
    */
  def executeInParallelUntilSuccess[T, U](elements: Seq[T], fn: (T) => Future[U], maxConcurrency: Int)(
      using ExecutionContext
  ): Future[U] =
    val partitionSize =
      if elements.size == 0 || maxConcurrency < 1 then 1
      else Math.ceil(elements.size.toFloat / maxConcurrency).toInt

    val status = AtomicBoolean(false)
    val futures = elements
      .grouped(partitionSize)
      .map { (subElements: Seq[T]) =>
        executeInSequenceUntilSuccess(
          subElements,
          el =>
            if status.get then Future.successful(None)
            else
              fn(el).map { res =>
                status.set(true)
                Some(res)
              }
        ).recover(_ => None)
      }

    Future.sequence(futures).map { results =>
      results.find(!_.isEmpty) match
        case Some(Some(res)) => res
        case _               => throw Exception("Executed all elements, but none worked")
    }

  /**
    * Executes all calls sequentially.
    * This is done by call one function and flatMap to call the next one.
    *
    * Whenever a computation fails its Future.Failure is returned.
    *
    * The order of the elements is kept. This function can be seen like an synchronous `map` operation, that is not blocking its thread.
    *
    * @return A sequence of the same size as the provided elements
    */
  def executeInSequence[T, U](elements: Seq[T], fn: (T) => Future[U])(using ExecutionContext): Future[Seq[U]] =
    val initF = Future.successful(ListBuffer.empty[U])
    elements.foldLeft(initF)((resF, el) => resF.flatMap(acc => fn(el).map(acc += _))).map(_.toSeq)

  /**
    * Executes all calls sequentially.
    * This is done by call one function and flatMap to call the next one.
    *
    * Results of failing queries are skipped.
    *
    * The order of the elements is kept. This function can be seen like an synchronous `collect` operation, that is not blocking its thread.
    *
    * @return A sequence of the same size as the provided elements
    */
  def executeInSequenceOnlySuccess[T, U](elements: Seq[T], fn: (T) => Future[U])(
      using ExecutionContext
  ): Future[Seq[U]] =
    val initF = Future.successful(ListBuffer.empty[U])
    elements
      .foldLeft(initF)((resF, el) => resF.flatMap(acc => fn(el).map(acc += _)).recoverWith(_ => resF))
      .map(_.toSeq)

  /**
    * Executes all calls sequentially until receiving a Future.Success
    * This is done by calling one function followed by recoverWith to call the next one.
    *
    * @return A Future.Success if one call worked, Future.Failure otherwise
    */
  def executeInSequenceUntilSuccess[T, U](elements: Seq[T], fn: (T) => Future[U])(
      using ExecutionContext
  ): Future[U] =
    elements match
      case Seq(head, tail*) => fn(head).recoverWith(_ => executeInSequenceUntilSuccess(tail, fn))
      case _                => Future.failed(Exception("Executed all elements, but none worked"))
